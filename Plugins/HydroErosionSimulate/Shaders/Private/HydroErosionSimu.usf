#include "/Engine/Public/Platform.ush"

// Vari
const static float size = 1024;
const static float deltaTime = 0.001;	//Temp
const static float Water_Brush_Radius = 0.01;

const static float Kc = 1.0f;
const static float Ks = 0.5f; //0.5f
const static float Kd = 1.f; //1.0f

// Func
int Index(uint3 id)
{
	return id.x + id.y * size;
}
int Index(uint2 id) {
	return clamp(id.x,1,size-2) + clamp(id.y,1,size-2) * size;
}
int Index(uint x, uint y) {
	return x + y * size;
}

//Increase Water FUnc
float Rain(float2 RainPos ,float2 Id ,float RainAmount)
{
	// rain rate
	float Kr = 0.05;
	
	float2 UV = Id / size;
	//RainPos = float2(0.5,0.5);
	float Ramp = 1-saturate((distance(RainPos , UV)*2) - Water_Brush_Radius);
	return pow(Ramp , 96)* RainAmount * Kr;
}

//		Init Pass
Texture2D InHeight;
RWStructuredBuffer<float> HeightBuffer;
RWStructuredBuffer<float> WaterHeightBuffer;
RWStructuredBuffer<float> SedimentBuffer;
RWStructuredBuffer<float4> OutFluxBuffer;
RWStructuredBuffer<float2> VelocityBuffr;
[numthreads(32,32,1)]
void InitSimuDataCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	WaterHeightBuffer[index] = 0;
	SedimentBuffer[index] = 0;
	OutFluxBuffer[index] = float4(0,0,0,0);
	VelocityBuffr[index] = float2(0,0);
	HeightBuffer[index] = InHeight.Load(int3(id.xy,0));
}


StructuredBuffer<float>  HeightBufferR;
RWStructuredBuffer<float> HeightBufferW;
[numthreads(32,32,1)]
void UpdateHeightTextureCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	HeightBufferW[index] = HeightBufferR[index];
}

//		Increase Water Buffer Pass
float TexSize;
float RainAmount;
float2 WaterCenter;
RWStructuredBuffer<float> WaterHeightW;
StructuredBuffer<float> WaterHeightR;
[numthreads(32,32,1)]
void IncreaseWaterCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	float Add_Water = Rain(WaterCenter , id ,RainAmount);

	WaterHeightW[index] = WaterHeightR[index] + Add_Water;
}


// OutFlux Calculate
//StructuredBuffer<float> HeightBufferR;
StructuredBuffer<float> WaterBufferR;
StructuredBuffer<float4> OutFluxBufferR;
RWStructuredBuffer<float4> OutFluxBufferW;
[numthreads(32,32,1)]
void OutFluxCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	const float A = 1.0f;	//管道横截面积
	const float g = 9.81f;	//重力加速度
	const float l = 1.0f;	//虚拟管道长度
	
	float2 UV = index / size;

	int2 L = int2(id.x -1 , id.y);
	int2 R = int2(id.x +1 , id.y);
	int2 T = int2(id.x ,  id.y+1);
	int2 B = int2(id.x ,  id.y-1);

	float Cur_BD= HeightBufferR[index] + WaterBufferR[index]; //bt(x,y) +d1(x,y)
	//Δ H^i t (x,y)
	float H_L = Cur_BD - HeightBufferR[Index(L)] - WaterBufferR[Index(L)];		//ΔHL_t = bt(x,y) + d1(x,y) - bt(x-1,y) + d1(x-1,y)
	float H_R = Cur_BD - HeightBufferR[Index(R)] - WaterBufferR[Index(R)];	
	float H_T = Cur_BD - HeightBufferR[Index(T)] - WaterBufferR[Index(T)];
	float H_B = Cur_BD - HeightBufferR[Index(B)] - WaterBufferR[Index(B)];

	//Fi t+Δt(x,y)
	float F_L = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_L / l);		//FL Δt+t (x,y) = max(0 , FL_t(x,y)) + Δt *A * g* ΔHL_t(x,y) /L)
	float F_R = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_R / l);	
	float F_T = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_T / l);
	float F_B = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_B / l);

	float K =min(1 , WaterBufferR[Index(id.x , id.y)] / ((F_L + F_B + F_R + F_T)*deltaTime) );		//Scale Factor :  K = min(1, d1 * Lx*LY /((FL+FR+FB+FT)*Δt))
	OutFluxBufferW[index] = float4( F_L , F_R , F_T , F_B ) * K ;
}


//StructuredBuffer<float4> OutFluxBufferR;
//StructuredBuffer<float> WaterBufferR;
RWStructuredBuffer<float> WaterBufferW;
RWStructuredBuffer<float2> VelocityBuffrW;
[numthreads(32,32,1)]
void UpdateWaterSurfaceAndVelocityFieldCS(uint3 id : SV_DispatchThreadID)
{
	#define FL(x,y) OutFluxBufferR[Index(x,y)].r
	#define FR(x,y) OutFluxBufferR[Index(x,y)].g
	#define FT(x,y) OutFluxBufferR[Index(x,y)].b
	#define FB(x,y) OutFluxBufferR[Index(x,y)].a
	
	int index = Index(id);

	int2 L = int2(id.x -1 , id.y);
	int2 R = int2(id.x +1 , id.y);
	int2 T = int2(id.x ,  id.y+1);
	int2 B = int2(id.x ,  id.y-1);

	int x = id.x;
	int y = id.y;
	
	//Water Buffer Update
	//Fi : R,L  G,R  B,T  A,B
	//Fr(x-1,y) + Fl(x+1 , y) + Ft(x,y-1) + Fb(x ,y+1)
	//float Sum_InFlux = OutFluxBufferR[Index(L)].g + OutFluxBufferR[Index(R)].r + OutFluxBuffer[Index(T)].a + OutFluxBufferR[Index(B)].b ;
	float Sum_InFlux = FR(x-1,y) + FL(x+1 , y) + FT(x,y-1) + FB(x ,y+1);
	//Fr(x,y) + Fl(x,y) + Ft(x,y) + Fb(x,y)
	//float Sum_OutFlux = OutFluxBufferR[index].r + OutFluxBufferR[index].g + OutFluxBufferR[index].b +OutFluxBufferR[index].a;
	float Sum_OutFlux = FR(x,y) + FL(x,y) + FT(x,y) + FB(x,y);
	//ΔV(x,y) = Δt * (Σ Fin - Σ Fout)
	float delta_V = deltaTime * (Sum_InFlux - Sum_OutFlux);
	//Update Water Surface
	float d2 = WaterBufferR[index] + delta_V / 4.0f;	//d2(x,y) = d1(x,y) + ΔV/(lx*ly) 
	WaterBufferW[index] = d2 ;	//water_Buffer : d2

	//Velocity Buffer Update
	float delta_WX = (FR(x-1 , y) - FL(x,y) + FR(x,y) - FL(x+1,y)) / 2.0f;
	float delta_WY = (FT(x , y-1) - FB(x,y) + FT(x,y) - FB(x,y+1)) / 2.0f;
	float d = (WaterBufferR[index] + d2) / 2.0f;
	float2 Out_Velocity = float2(delta_WX / d  , delta_WY / d );
	VelocityBuffrW[index] = Out_Velocity;
}


StructuredBuffer<float2>  VelocityBufferR;
//StructuredBuffer<float>  HeightBufferR;
StructuredBuffer<float>  SedimentBufferR;
RWStructuredBuffer<float> SedimentBufferW;
//RWStructuredBuffer<float> HeightBufferW;
[numthreads(32,32,1)]
void ErosionDepositionCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id.xy);
	int2 L = int2(id.x -1 , id.y);
	int2 R = int2(id.x +1 , id.y);
	int2 T = int2(id.x ,  id.y+1);
	int2 B = int2(id.x ,  id.y-1);
	//local tilt angle : b(x-1, y) + b(x+1 ,y) +b(x,y-1) +b(x,y+1) - 4*b(xy);
	float a = abs(HeightBufferR[Index(L)] + HeightBufferR[Index(R)] + HeightBufferR[Index(T)] + HeightBufferR[Index(B)] - 4*HeightBufferR[index]);	
	float C_xy = Kc * sin(a) * length(VelocityBufferR[index]);

	if (C_xy > SedimentBufferR[index])	//C > St
	{
		//Bt+Δt = Bt - Ks(C - St)
		HeightBufferW[index] = HeightBufferR[index] - Ks*(C_xy - SedimentBufferR[index]);
		//S1 = St + Ks(C - St)
		SedimentBufferW[index] = SedimentBufferR[index] + Ks*(C_xy - SedimentBufferR[index]);
	}
	else	//C <= St
	{
		//Bt+Δt = Bt + Kd(St - C) 
		HeightBufferW[index] = HeightBufferR[index] + Kd*( SedimentBufferR[index] - C_xy );
		//S1 = St -Kd(St - C)
		SedimentBufferW[index] = SedimentBufferR[index] - Kd*(SedimentBufferR[index] - C_xy );
	}
}


//		Debug Pass
StructuredBuffer<float2> InFloat2Buffer;
StructuredBuffer<float> InFloatBuffer;
StructuredBuffer<float> InHeightBuffer;
RWTexture2D<float4> OutTexture;
[numthreads(32,32,1)]
void DebugVisulizeCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	
	OutTexture[id.xy]  = float4( (InFloat2Buffer[index].xy+1)/2 , InFloatBuffer[index].r ,InHeightBuffer[index].r);
	//OutTexture[id.xy]  = float4(1.0,0.0,1.0,1.0);
}