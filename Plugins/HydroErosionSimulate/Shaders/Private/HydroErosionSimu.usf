#include "/Engine/Public/Platform.ush"

// Vari
const static float size = 1024;
const static float deltaTime = 0.01;	//Temp
const static float Water_Brush_Radius = 0.01;

// Func
int Index(uint3 id)
{
	return id.x + id.y * size;
}
int Index(uint2 id) {
	return clamp(id.x,1,size-2) + clamp(id.y,1,size-2) * size;
}
int Index(uint x, uint y) {
	return x + y * size;
}

//Increase Water FUnc
float Rain(float2 RainPos ,float2 Id ,float RainAmount)
{
	float2 UV = Id / size;
	RainPos = float2(0.5,0.5);
	float Ramp = 1-saturate((distance(RainPos , UV)*2) - Water_Brush_Radius);
	return pow(Ramp , 128)*RainAmount;
}

//		Init Pass
RWStructuredBuffer<float> WaterHeightBuffer;
RWStructuredBuffer<float> SedimentBuffer;
RWStructuredBuffer<float4> OutFluxBuffer;
RWStructuredBuffer<float2> VelocityBuffr;
[numthreads(32,32,1)]
void InitSimuDataCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	WaterHeightBuffer[index] = 0;
	SedimentBuffer[index] = 0;
	OutFluxBuffer[index] = float4(0,0,0,0);
	VelocityBuffr[index] = float2(0,0);
}

Texture2D  HeightTextureR;
SamplerState TexSampler;
RWTexture2D<float4> HeightTextureW;
[numthreads(32,32,1)]
void UpdateHeightTextureCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	float2 UV = id.xy / size;
	float HeightRaw = HeightTextureR.Load(int3(id.x , id.y ,0));
	
		//这里后面添加修改高度函数
	
	HeightTextureW[id.xy] = float4(HeightRaw,0,0,1);
}

//		Increase Water Buffer Pass
float TexSize;
float RainAmount;
float2 WaterCenter;
RWStructuredBuffer<float> WaterHeightW;
StructuredBuffer<float> WaterHeightR;
[numthreads(32,32,1)]
void IncreaseWaterCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	float Add_Water = Rain(WaterCenter , id ,RainAmount);

	WaterHeightW[index] = WaterHeightR[index] + Add_Water;
}


// OutFlux Calculate
Texture2D HeightTexture;
SamplerState HeightTextureSampler;
StructuredBuffer<float> WaterBufferR;
StructuredBuffer<float4> OutFluxBufferR;
RWStructuredBuffer<float4> OutFluxBufferW;
[numthreads(32,32,1)]
void OutFluxCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	const float A = 1.0f;	//管道横截面积
	const float g = -9.80f;	//重力加速度
	const float l = 1.0f;	//虚拟管道长度
	
	float2 UV = index / size;

	int2 L = int2(id.x -1 , id.y);
	int2 R = int2(id.x +1 , id.y);
	int2 T = int2(id.x ,  id.y+1);
	int2 B = int2(id.x ,  id.y-1);
	
	int3 Sampler_C= int3(id.x, id.y , 0);
	int3 Sampler_L= int3(L, 0);
	int3 Sampler_R= int3(R, 0);
	int3 Sampler_T= int3(T, 0);
	int3 Sampler_B= int3(B, 0);

	float Cur_BD= HeightTexture.Load(Sampler_C).r - WaterBufferR[Index(id.x , id.y)] ;
	//Δ H^i t (x,y)
	float H_L = Cur_BD + HeightTexture.Load(int3(Sampler_L)) - WaterBufferR[Index(L)];		//ΔHL_t = bt(x,y) + d1(x,y) - bt(x-1,y) + d1(x-1,y)
	float H_R = Cur_BD + HeightTexture.Load(int3(Sampler_R)) - WaterBufferR[Index(R)];	
	float H_T = Cur_BD + HeightTexture.Load(int3(Sampler_T)) - WaterBufferR[Index(T)];
	float H_B = Cur_BD + HeightTexture.Load(int3(Sampler_B)) - WaterBufferR[Index(B)];

	//Fi t+Δt(x,y)
	float F_L = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_L / l);		//FL Δt+t (x,y) = max(0 , FL_t(x,y)) + Δt *A * g* ΔHL_t(x,y) /L)
	float F_R = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_R / l);	
	float F_T = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_T / l);
	float F_B = max(0 , OutFluxBufferR[index] + deltaTime * A * g * H_B / l);

	float K =min(1 , WaterBufferR[Index(id.x , id.y)] / ((F_L + F_B + F_R + F_T)*deltaTime) );		//Scale Factor :  K = min(1, d1 * Lx*LY /((FL+FR+FB+FT)*Δt))
	OutFluxBufferW[index] = float4( F_L , F_R , F_T , F_B ) * K ;
}


//StructuredBuffer<float4> OutFluxBufferR;
//StructuredBuffer<float> WaterBufferR;
RWStructuredBuffer<float> WaterBufferW;
RWStructuredBuffer<float2> VelocityBuffrW;
[numthreads(32,32,1)]
void UpdateWaterSurfaceAndVelocityFieldCS(uint3 id : SV_DispatchThreadID)
{
	#define FL(x,y) OutFluxBufferR[Index(x,y)].r
	#define FR(x,y) OutFluxBufferR[Index(x,y)].g
	#define FT(x,y) OutFluxBufferR[Index(x,y)].b
	#define FB(x,y) OutFluxBufferR[Index(x,y)].a
	
	int index = Index(id);

	int2 L = int2(id.x -1 , id.y);
	int2 R = int2(id.x +1 , id.y);
	int2 T = int2(id.x ,  id.y+1);
	int2 B = int2(id.x ,  id.y-1);

	int x = id.x;
	int y = id.y;
	
	//Water Buffer Update
	//Fi : R,L  G,R  B,T  A,B
	//Fr(x-1,y) + Fl(x+1 , y) + Ft(x,y-1) + Fb(x ,y+1)
	//float Sum_InFlux = OutFluxBufferR[Index(L)].g + OutFluxBufferR[Index(R)].r + OutFluxBuffer[Index(T)].a + OutFluxBufferR[Index(B)].b ;
	float Sum_InFlux = FR(x-1,y) + FL(x+1 , y) + FT(x,y-1) + FB(x ,y+1);
	//Fr(x,y) + Fl(x,y) + Ft(x,y) + Fb(x,y)
	//float Sum_OutFlux = OutFluxBufferR[index].r + OutFluxBufferR[index].g + OutFluxBufferR[index].b +OutFluxBufferR[index].a;
	float Sum_OutFlux = FR(x,y) + FL(x,y) + FT(x,y) + FB(x,y);
	//ΔV(x,y) = Δt * (Σ Fin - Σ Fout)
	float delta_V = deltaTime * (Sum_InFlux - Sum_OutFlux);
	//Update Water Surface
	float d2 = WaterBufferR[index] + delta_V;	//d2(x,y) = d1(x,y) + ΔV/(lx*ly) 
	WaterBufferW[index] = d2 ;	//water_Buffer : d2

	//Velocity Buffer Update
	float delta_WX = (FR(x-1 , y) - FL(x,y) + FR(x,y) - FL(x+1,y)) / 2.0f;
	float delta_WY = (FT(x , y-1) - FB(x,y) + FT(x,y) - FB(x,y+1)) / 2.0f;
	float d = (WaterBufferR[index] + d2) / 2.0f;
	float2 Out_Velocity = float2(delta_WX / d  , delta_WY / d );
	VelocityBuffrW[index] = Out_Velocity;
}


//		Debug Pass
StructuredBuffer<float4> InFloatBuffer;
RWTexture2D<float4> OutTexture;
[numthreads(32,32,1)]
void DebugVisulizeCS(uint3 id : SV_DispatchThreadID)
{
	int index = Index(id);
	OutTexture[id.xy]  = float4(InFloatBuffer[index]);
	//OutTexture[id.xy]  = float4(1.0,0.0,1.0,1.0);
}