#include "/Engine/Public/Platform.ush"



const static float TexSize = 1024;
const static float Water_Brush_Radius = 0.0f;
const static float Height_Brush_Radius = 0.0f;
const static float Kr = 0.0025;		//Rain Factor
const static float Kh = 0.0025;

const static float2 L = float2(-1,0);
const static float2 R = float2(1,0);
const static float2 T = float2(0,1);
const static float2 B = float2(0,-1);
	
const static float2 L_Bias = L/TexSize;
const static float2 R_Bias = R/TexSize;
const static float2 T_Bias = T/TexSize;
const static float2 B_Bias = B/TexSize;

const static float PipeLength = 1.0f/TexSize;
const static float deltaTime = 0.015f;
const static float Gravity = 9.81f;
const static float PipeArea = 20.0f;
const static float CellSize = 1.0f/TexSize;
const static float MaxErosionDepth = 5.f;
const static float SedimentCapacity = 1.0f;
const static float Ks = 0.5;
const static float Kd = 1.0;
const static float Ke = 0.05f;
const static float SedimentSofteningRate = 1.f;

int Index(uint3 id){
	return id.x + id.y * TexSize;
}
int Index(uint2 id) {
	return clamp(id.x,1,TexSize-2) + clamp(id.y,1,TexSize-2) * TexSize;
}
int Index(uint x, uint y) {
	return x + y * TexSize;
}

float2 GetUV(RWTexture2D<float4> Tex ,int3 id)
{
	float sizeX, sizeY;
	Tex.GetDimensions(sizeX, sizeY);
	float2 iResolution = float2(sizeX,sizeY);
	return (id.xy+0.5) / iResolution;
}
//Increase Water Func
float Rain(float2 RainPos ,float2 UV ,float RainAmount)
{
	//return 0.1f;
	//RainPos = float2(0.5,0.5);
	float Ramp = 1-saturate((distance(RainPos , UV)*2) - Water_Brush_Radius);
	return saturate(pow(Ramp , 32))* RainAmount * Kr ;
}
float HeightAdd(float2 RainPos ,float2 UV ,float HeightAmount)
{
	//return 0.1f;
	//RainPos = float2(0.5,0.5);
	float Ramp = 1-saturate((distance(RainPos , UV)*2) - Height_Brush_Radius);
	return saturate(pow(Ramp , 32))* HeightAmount * Kh ;
}




Texture2D InHeightMapTex;
SamplerState InHeightMapTexSampler;

//R : L
//G : R
//B : T
//A : B
StructuredBuffer<float4> FluxR;
//VlocityField
StructuredBuffer<float2> VelocityR;
// R : height
// G : water height
// B : suspended sediment amount
// A : Surface hardness
RWTexture2D<float4> SimulateTexW;
// Water Flux Field
RWStructuredBuffer<float4> FluxW;
// Velocity Field
RWStructuredBuffer<float2> VelocityW;
// Flux Field

//DebugTexture
RWTexture2D<float4> DebugTex;



[numthreads(32,32,1)]
void InitSimuData(uint3 id :SV_DispatchThreadID)
{
	int index = Index(id);

	float Init_RainInit_Rain = 0.0;
	float Init_Sediment = 0;
	float Init_Hardness = 0.;
	float2 UV = id.xy / TexSize; 
	SimulateTexW[id.xy] =float4(InHeightMapTex.SampleLevel(InHeightMapTexSampler ,UV, 0).r,
										Init_RainInit_Rain,
										Init_Sediment,
										Init_Hardness);
	FluxW[index] = float4(0,0,0,0);
	VelocityW[index] = float2(0,0);
}

Texture2D SimulateTexR;
SamplerState SimulateTexSampler;
/*StructuredBuffer<float> WaterHeightR;
StructuredBuffer<float> WaterHeightW;*/

float4 SimulateTex( float2 UV ,float2 Offset = float2(0,0))
{
	return SimulateTexR.SampleLevel(SimulateTexSampler, UV + Offset, 0);
}

#define HEIGHT(state) (state.r)
#define WATER(state) (state.g)
#define SEDIMENT(state) (state.b)
#define HARDNESS(state) (state.a)
#define FULL_HEIGHT(state) (HEIGHT(state)+WATER(state))

#define LDIR(OutFlux) (OutFlux.r)
#define RDIR(OutFlux) (OutFlux.g)
#define TDIR(OutFlux) (OutFlux.b)
#define BDIR(OutFlux) (OutFlux.a)
#define SUM_FLUX(F) (F.r + F.g + F.b + F.a)

// Sampling macro, just to simplify the code a bit
#define SAMPLE_WITH_OFFSET(tex, x, y) (( tex[Index(id.xy + uint2(x,y))] ))

#define LEFT_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, -1, 0))
#define RIGHT_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 1, 0))
#define TOP_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 0, 1))
#define BOTTOM_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 0, -1))


float3 RainData;
float HeightAmount;
[numthreads(32,32,1)]
void UpdateWaterAndHeightCS(uint3 id :SV_DispatchThreadID)
{
	int index = Index(id.xy);
	
	float2 UV = GetUV(SimulateTexW , id);
	float4 state = SimulateTex(UV).rgba;
	float HeightIncrease = HEIGHT(state) + HeightAdd(RainData.xy , UV, HeightAmount);
	float WaterIncrease = WATER(state) + Rain( RainData.xy , UV, RainData.z);
	SimulateTexW[id.xy] = float4(HeightIncrease , WaterIncrease , state.z , state.w);
	//SimulateTexW[id.xy] = state;
}




[numthreads(32,32,1)]
void OutFluxComputeCS(uint3 id:SV_DispatchThreadID)
{
	int index = Index(id.xy);
	
	float2 UV = (id.xy+0.5) / TexSize;
	float4 State = SimulateTex(UV );
	float4 L_State = SimulateTex(UV, L_Bias);
	float4 R_State = SimulateTex(UV, R_Bias);
	float4 T_State = SimulateTex(UV, T_Bias);
	float4 B_State = SimulateTex(UV, B_Bias);

	float Terrain_Height = HEIGHT(State);
	float Water_Height = WATER(State);
	
	float4 Cur_OutFlux = FluxR[index];

	float4 Full_Height_diff = ((float4)FULL_HEIGHT(State)) - float4(FULL_HEIGHT(L_State) ,
															 	  FULL_HEIGHT(R_State),
																  FULL_HEIGHT(T_State),
															 	  FULL_HEIGHT(B_State));
	float4 OutFlux = max(0 , Cur_OutFlux + deltaTime * Gravity * PipeArea * Full_Height_diff / PipeLength);

	float K =max(0.1 , min(1, (Water_Height * CellSize * CellSize) / (SUM_FLUX(OutFlux) )* deltaTime)  );
	//K = 1;
	
	if (id.x == 0)  LDIR(OutFlux)=0.0f;
	if (id.y == 0)	BDIR(OutFlux)=0.0f;
	if (id.x == TexSize - 1) RDIR(OutFlux)=0.0f;
	if (id.y == TexSize - 1) TDIR(OutFlux)=0.0f;

	OutFlux *= K;

	//FluxW[index] = max(0, K*OutFlux);
	FluxW[index] = max(0 , OutFlux);
	DebugTex[id.xy] = max(0 ,OutFlux);
}

[numthreads(32,32,1)]
void VelocityComputeCS(uint3 id:SV_DispatchThreadID)
{
	int index = Index(id.xy);
	float2 UV = GetUV(SimulateTexW ,id);
	float4 state = SimulateTex(UV);
	float4 outputFlux = FluxR[index];
	float4 inputFlux = float4(
		RDIR(LEFT_SAMPLE(FluxR)),
		LDIR(RIGHT_SAMPLE(FluxR)),
		BDIR(TOP_SAMPLE(FluxR)),
		TDIR(BOTTOM_SAMPLE(FluxR)));
	float waterHeightBefore = WATER(state);
	float volumeDelta = SUM_FLUX(inputFlux) - SUM_FLUX(outputFlux) * deltaTime;

	WATER(state) +=   volumeDelta / (TexSize*TexSize)  ;	//这里考虑要不要乘以 WATER(state)

	SimulateTexW[id.xy] = saturate( state );

	float2 Velocity_Out = float2(
	0.5 * (LDIR(inputFlux) - LDIR(outputFlux) + RDIR(outputFlux) - RDIR(inputFlux)),
	0.5 * (BDIR(inputFlux) - BDIR(outputFlux) + TDIR(outputFlux) - TDIR(inputFlux))) *  0.5 * (waterHeightBefore + WATER(state))  ;
	VelocityW[index] = Velocity_Out;
	//DebugTex[id.xy] = float4(Velocity_Field,0,1);

	//Debug
	DebugTex[id.xy] = float4(Velocity_Out,0,1);
	
}

[numthreads(32,32,1)]
void HydroErosionCS(uint3 id:SV_DispatchThreadID)
{
	// /*Debug*/
	// int index = Index(id.xy);
	// float2 UV = GetUV(SimulateTexW,id);
	// float4 State = SimulateTex(UV);
	// SimulateTexW[id.xy] = State;
	
	int index = Index(id.xy);
	
	float2 UV = GetUV(SimulateTexW,id);
	
	float4 state = SimulateTex(UV);
	float4 stateLeft = SimulateTex(UV, L_Bias);
	float4 stateRight = SimulateTex(UV, R_Bias);
	float4 stateTop = SimulateTex(UV, T_Bias);
	float4 stateBottom = SimulateTex(UV, B_Bias);
	float2 velocity = VelocityR[index];

	// Tilt angle computation
	float3 dhdx = float3(1, 0, 0) * (HEIGHT(stateRight) - HEIGHT(stateLeft));
	float3 dhdy = float3(0, 0, 1) * (HEIGHT(stateTop) - HEIGHT(stateBottom));
	float3 normal = cross(dhdx, dhdy);

	float sinTiltAngle = abs(normal.y) / length(normal);

	// Erosion limiting factor
	float lmax = saturate(1 - max(0, MaxErosionDepth - WATER(state)) / MaxErosionDepth);
	float sedimentTransportCapacity = SedimentCapacity * length(velocity) * min(sinTiltAngle, 0.05) * lmax;

	float New_Height;
	float New_Sediment;
	float New_NewWater;
	if(SEDIMENT(state) < sedimentTransportCapacity)
	{
		float mod = deltaTime * Ks * HARDNESS(state)* (sedimentTransportCapacity - SEDIMENT(state));	
		New_Height = HEIGHT(state) - mod;
		New_Sediment = SEDIMENT(state) + mod;
		New_NewWater = WATER(state) + mod;
	}
	else
	{
		float mod = deltaTime * Kd * (SEDIMENT(state) - sedimentTransportCapacity);
		New_Height = HEIGHT(state) + mod;
		New_Sediment = SEDIMENT(state) - mod;
		New_NewWater = WATER(state) - mod;
	}
	New_NewWater *= 1- Ke*deltaTime ;

	float New_Hardness = HARDNESS(state) - deltaTime * SedimentSofteningRate * Ks * (SEDIMENT(state) - sedimentTransportCapacity);
	New_Hardness = clamp(New_Hardness , 0.1 , 1.0);
	float4 OutResult = float4(New_Height , New_NewWater , New_Sediment ,New_Hardness);

	SimulateTexW[id.xy] = OutResult;
	//DebugTex[id.xy] = sinTiltAngle;

	//Debug
	//New_NewWater = WATER(State);
	//DebugTex[id.xy] = SimulateTex(UV);
}

[numthreads(32,32,1)]
void SedimentAdvectionCS(uint3 id:SV_DispatchThreadID)
{
	int index = Index(id.xy);
	float2 UV = GetUV(SimulateTexW ,id);
	float4 state = SimulateTex(UV);
	float2 velocity = VelocityR[index]; 

	// Sediment advection
	WATER(state) *= 1-Ke*deltaTime;
	SEDIMENT(state) = SEDIMENT(SimulateTex( UV.xy , -velocity * deltaTime ));
	WATER(state) = WATER(SimulateTex( UV.xy , -velocity * deltaTime ));
	
	float4 stateLeft = SimulateTex(UV, L_Bias);
	float4 stateRight = SimulateTex(UV, R_Bias);
	float4 stateTop = SimulateTex(UV, T_Bias);
	float4 stateBottom = SimulateTex(UV, B_Bias);

	// Tilt angle computation
	float3 dhdx = float3(1, 0, 0) * (HEIGHT(stateRight) - HEIGHT(stateLeft));
	float3 dhdy = float3(0, 0, 1) * (HEIGHT(stateTop) - HEIGHT(stateBottom));
	float3 normal = cross(dhdx, dhdy);
	float sinTiltAngle = abs(normal.y) / length(normal);

	// Erosion limiting factor
	float lmax = saturate(1 - max(0, MaxErosionDepth - WATER(state)) / MaxErosionDepth);
	float sedimentTransportCapacity = SedimentCapacity * length(velocity) * min(sinTiltAngle, 0.0) * lmax;
	sedimentTransportCapacity = max(0.025 ,sedimentTransportCapacity);

	float selfWeight = 0.35;
	float otherWeight = (1-selfWeight)/4;
	float blurHeight = ((HEIGHT(stateLeft)*otherWeight + HEIGHT(stateRight)*otherWeight + HEIGHT(stateTop)*otherWeight + HEIGHT(stateBottom) + HEIGHT(state)*selfWeight)/5) ;
	
	// HEIGHT(state) = lerp(HEIGHT(state) , ((HEIGHT(stateLeft) + HEIGHT(stateRight) + HEIGHT(stateTop) + HEIGHT(stateBottom) )/4) ,  WATER(state)*HARDNESS(state)*deltaTime); 

	HEIGHT(state) += (HEIGHT(stateLeft) + HEIGHT(stateRight) + HEIGHT(stateTop) + HEIGHT(stateBottom) - 4*HEIGHT(state) ) * WATER(state)*HARDNESS(state)*deltaTime *sedimentTransportCapacity;
	
	SimulateTexW[id.xy] = state;
	// Write heightmap
	//SimulateTexW[id.xy] = sedimentTransportCapacity;
	//DebugTex[id.xy] = 0.0f;
}