#include "/Engine/Public/Platform.ush"



const static float TexSize = 1024;
const static float Water_Brush_Radius = 0.025f;
const static float Kr = 0.25;		//Rain Factor



int Index(uint3 id){
	return id.x + id.y * TexSize;
}
int Index(uint2 id) {
	return clamp(id.x,1,TexSize-2) + clamp(id.y,1,TexSize-2) * TexSize;
}
int Index(uint x, uint y) {
	return x + y * TexSize;
}

float2 GetUV(RWTexture2D<float4> Tex ,int3 id)
{
	float sizeX, sizeY;
	Tex.GetDimensions(sizeX, sizeY);
	float2 iResolution = float2(sizeX,sizeY);
	return (id.xy+0.5) / iResolution;
}
//Increase Water Func
float Rain(float2 RainPos ,float2 UV ,float RainAmount)
{
	//return 0.1f;
	//RainPos = float2(0.5,0.5);
	float Ramp = 1-saturate((distance(RainPos , UV)*2) - Water_Brush_Radius);
	return saturate(pow(Ramp , 64))* RainAmount * Kr;
}
float HeightAdd()
{
	return 0.f;
}




Texture2D InHeightMapTex;
SamplerState InHeightMapTexSampler;

//R : L
//G : R
//B : T
//A : B
StructuredBuffer<float4> FluxR;
// R : height
// G : water height
// B : suspended sediment amount
// A : Surface hardness
RWTexture2D<float4> SimulateTexW;
// Water Flux Field
RWStructuredBuffer<float4> FluxW;
// Velocity Field
RWStructuredBuffer<float2> VelocityW;
// Flux Field

//DebugTexture
RWTexture2D<float4> DebugTex;


[numthreads(32,32,1)]
void InitSimuData(uint3 id :SV_DispatchThreadID)
{
	int index = Index(id);

	float Init_RainInit_Rain = 0.05;
	float Init_Sediment = 0;
	float Init_Hardness = 0;
	float2 UV = id.xy / TexSize; 
	SimulateTexW[id.xy] =float4(InHeightMapTex.SampleLevel(InHeightMapTexSampler ,UV, 0).r,
										Init_RainInit_Rain,
										Init_Sediment,
										Init_Hardness);
	FluxW[index] = float4(0,0,0,0);
	VelocityW[index] = float2(0,0);
}

Texture2D SimulateTexR;
SamplerState SimulateTexSampler;
/*StructuredBuffer<float> WaterHeightR;
StructuredBuffer<float> WaterHeightW;*/

float4 SimulateTex( float2 UV ,float2 Offset = float2(0,0))
{
	return SimulateTexR.SampleLevel(SimulateTexSampler, UV + Offset, 0);
}

#define HEIGHT(state) (state.r)
#define WATER(state) (state.g)
#define SEDIMENT(state) (state.b)
#define HARDNESS(state) (state.a)
#define FULL_HEIGHT(state) (HEIGHT(state)+WATER(state))

#define LDIR(OutFlux) (OutFlux.r)
#define RDIR(OutFlux) (OutFlux.g)
#define TDIR(OutFlux) (OutFlux.b)
#define BDIR(OutFlux) (OutFlux.a)
#define SUM_FLUX(F) (F.r + F.g + F.b + F.a)

float3 RainData;
[numthreads(32,32,1)]
void UpdateWaterAndHeightCS(uint3 id :SV_DispatchThreadID)
{
	int index = Index(id.xy);
	
	float2 UV = GetUV(SimulateTexW , id);
	float4 state = SimulateTex(UV).rgba;
	float HeightIncrease = HEIGHT(state) + HeightAdd();
	float WaterIncrease = WATER(state) + Rain( RainData.xy , UV, RainData.z);
	SimulateTexW[id.xy] = float4(HeightIncrease , WaterIncrease , state.z , state.w);
	//SimulateTexW[id.xy] = state;
}

const static float2 L = float2(-1,0);
const static float2 R = float2(1,0);
const static float2 T = float2(0,1);
const static float2 B = float2(0,-1);
	
const static float2 L_Bias = L/TexSize;
const static float2 R_Bias = R/TexSize;
const static float2 T_Bias = T/TexSize;
const static float2 B_Bias = B/TexSize;

const static float PipeLength = 1.0f/TexSize;
const static float deltaTime = 0.01f;
const static float Gravity = 9.81f;
const static float PipeArea = 20.0f;
const static float CellSize = 1.0f/TexSize;

[numthreads(32,32,1)]
void OutFluxComputeCS(uint3 id:SV_DispatchThreadID)
{
	int index = Index(id.xy);
	
	float2 UV = (id.xy+0.5) / TexSize;
	float4 State = SimulateTex(UV );
	float4 L_State = SimulateTex(UV, L_Bias);
	float4 R_State = SimulateTex(UV, R_Bias);
	float4 T_State = SimulateTex(UV, T_Bias);
	float4 B_State = SimulateTex(UV, B_Bias);

	float Terrain_Height = HEIGHT(State);
	float Water_Height = WATER(State);
	
	float4 Cur_OutFlux = FluxR[index];

	float4 Full_Height_diff = ((float4)FULL_HEIGHT(State)) - float4(FULL_HEIGHT(L_State) ,
															 	  FULL_HEIGHT(R_State),
																  FULL_HEIGHT(T_State),
															 	  FULL_HEIGHT(B_State));
	float4 OutFlux = max(0 , Cur_OutFlux + deltaTime * Gravity * PipeArea * Full_Height_diff / PipeLength);

	float K = min(1, Water_Height * CellSize*CellSize / (SUM_FLUX(OutFlux) * deltaTime)); 
	
	if (id.x == 0)  LDIR(OutFlux)=0.0f;
	if (id.y == 0)	BDIR(OutFlux)=0.0f;
	if (id.x == TexSize - 1) RDIR(OutFlux)=0.0f;
	if (id.y == TexSize - 1) TDIR(OutFlux)=0.0f;	

	FluxW[index] = max(0, K*OutFlux);
	DebugTex[id.xy] =  frac(max(0 ,OutFlux));
}